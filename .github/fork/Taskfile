#!/usr/bin/env bash

[ "${BASH_VERSINFO:-0}" -ge 4 ] || {
  echo "bash version 4 or higher is required" >&2
  exit 1
}

set -euo pipefail

# How to use it
#  - run patch
#  - run --increment patch
#  - run patch vX.Y.Z
#  - run --increment patch vX.Y.Z
#  - run patch -- vA.B.C
#  - run --increment patch -- vA.B.C
#  - run patch vX.Y.Z -- vA.B.C
#  - run --increment patch vX.Y.Z -- vA.B.C
#  - run -d patch vX.Y.Z -- vA.B.C > bin/transaction.bash
#  - run release
#  - run --increment release
#  - run release vX.Y.Z
#  - run --increment release vX.Y.Z
#  - run -d release vX.Y.Z > bin/transaction.bash
#  - run -d --increment release vX.Y.Z > bin/transaction.bash

declare -A config
config['branch']=extended
config['detach']=false
config['dryrun']=false
config['reason']=fork
config['source']=kamilsk/fork
config['target']=upstream/main
config['vendor']=github.com/vendor/module

declare -A remotes
remotes['origin']="git@github.com:${config['source']}.git"
remotes['upstream']=git@github.com:upstream/source.git
order=(origin upstream)

function amend() {
  local _ad _cd
  _ad=$(git --no-pager log -1 --format="%aI")
  _cd=$(git --no-pager log -1 --format="%cI")
  GIT_COMMITTER_DATE="${_cd}" git commit --amend --date="${_ad}" --no-edit "${@}"
}

function check() {
  [ "$(git rev-parse --abbrev-ref HEAD)" == "${config['branch']}" ]
  [ "${#remotes[@]}" == "${#order[@]}" ]
}

function clean() {
  # we have to delete remote branches
  git branch -a | grep remotes/ |
    # except upstream' branches,
    grep -v /upstream |
    # the current and dependabot's
    grep -vE /"${config['branch']}"\|/dependabot/ |
    # clean-up and separate remote and branch names
    sed 's|remotes/||g' |
    sed 's|/| |' |
    # bat -P && return | # debug pipe before deleting branches
    prune || true

  # we have to delete useless tags
  git tag --list |
    # exclude valid semver tags
    grep -v '^v[0-9]' |
    # exclude the reason
    grep -v "${config['reason']}" |
    # bat -P && return | # debug pipe before deleting tags
    untag || true
}

function fetch() {
  for remote in "${order[@]}"; do
    _ git fetch "${remote}" --force --prune --tags
  done
}

function patch() {
  local vendor=latest version

  case "${#}" in
  3)
    version=${1}
    vendor=${3}
    ;;
  2) vendor=${2} ;;
  1) version=${1} ;;
  esac

  _ git rebase -i "${config['reason']}"
  _ go mod edit -require="${config['vendor']}@${vendor}"
  _ go mod tidy
  _ git add .
  _ amend
  _ git rebase --continue
  release "${version:-$(version)}"
}

function prune() {
  local remote branch
  while read -r remote branch; do
    _ git push -d "${remote}" "${branch}"
  done
}

function setup() {
  for remote in $(git remote -v | awk '{print $1}' | sort | uniq); do
    _ git remote rm "${remote}"
  done

  for remote in "${!remotes[@]}"; do
    _ git remote add "${remote}" "${remotes[$remote]}"
  done
}

function untag() {
  local tag
  while read -r tag; do
    _ git tag -d "${tag}" || true
    for remote in $(git remote | grep -v upstream); do
      _ git push "${remote}" :refs/tags/"${tag}" || true
    done
  done
}

function publish() {
  local version=${1}
  _ gh release -R "${config['source']}" delete "${version}" -y || true
  _ gh release -R "${config['source']}" edit "${config['reason']}" --draft=false --prerelease
  _ goreleaser --clean --release-notes CHANGES.md
  _ rm -rf dist
  _ gh release -R "${config['source']}" view "${version}" -w
}

function release() {
  check
  fetch
  clean

  # define the release version: passed or latest,
  # and it's commit to creating the new tag on it
  local version=${1:-$(version)}

  # prepare release
  local fork
  fork=$(git merge-base --fork-point "${version}" 2>/dev/null || git rev-list -n1 "${version}")
  _ git rebase --onto "${version}" "${config['target']}"
  if ${config['detach']}; then
    version=$(increment "${version}")
  else
    untag <<<"${version}"
  fi
  _ git tag -m "'sync with upstream'" "${version}"
  untag <<<"${config['reason']}"
  _ git tag -m "'extend by ${config['reason']}'" "${config['reason']}" "${fork}"

  # do release
  for remote in $(git remote | grep -v upstream); do
    _ git push --force-with-lease "${remote}" "${config['branch']}"
    _ git push "${remote}" "refs/tags/${config['reason']}"
    _ git push "${remote}" "refs/tags/${version}"
  done
  publish "${version}"

  # add build metadata
  if ${config['detach']}; then return; fi
  local revision
  revision=$(git rev-parse --short HEAD)
  _ git tag -m "'specific build version'" "${version}+${revision}"
  for remote in $(git remote | grep -v upstream); do
    _ git push "${remote}" "refs/tags/${version}+${revision}"
  done
}

function version() {
  git ls-remote --tags --sort=-v:refname "${remotes['upstream']}" |
    head -1 |
    awk -F/ '{print $3}'
}

function increment() {
  local latest=${1} prefix
  prefix=$(echo "${latest}" | awk -F. '{NF--} 1' | sed 's/ /./g')
  git tag --list --sort=-v:refname |
    grep "${prefix}" |
    head -1 |
    awk -F. '{$NF++} 1' |
    sed 's/ /./g'
}

function installer() {
  godownloader .goreleaser.yml >bin/install
}

_() {
  if ${config['dryrun']}; then
    echo "${@}"
    return
  fi
  trap 'echo "${@}"' ERR
  "${@}"
}
@debug() { echo "${@}"; }
@trace() { @debug "${@}" && "${@}"; }
@error() { echo "${@}" >&2; }
@fatal() { @error "${@}" && exit 1; }
@usage() {
  cat - <<EOF
Usage: $0 <task> <args>
Tasks:
EOF
  compgen -A function | grep -Ev '^(@|_)' | sort | cat -n
}

function @main() {
  for arg in "${@}"; do
    case "${arg}" in
    --increment)
      config['detach']=true
      shift
      ;;
    -d | --dry-run)
      config['dryrun']=true
      shift
      ;;
    esac
  done
  "${@:-@usage}"
}

@main "${@}"
